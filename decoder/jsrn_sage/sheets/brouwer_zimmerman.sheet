### Experimental implementation of the Brouwer--Zimmermann algorithm

def random_non_zero(F):
    while True:
        a = F.random_element()
        if not a.is_zero():
            return a


# TODO: Literature

def is_information_set(C, positions):
    r"""
    Return whether the given positions form an information set of the linear
    code `C`.

    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,1,1,1,1,1,0,0],
                                 [0,0,0,1,1,0,1,1,0,0],
                                 [1,0,0,0,1,1,0,1,0,1]])
        sage: C = LinearCode(G)
        sage: is_information_set(C, [0,1,2])
        False
        sage: is_information_set(C, [0,1,3])
        True
    """
    k = C.dimension()
    if len(positions) != k:
        return False
    non_pos = set(range(C.length())).difference(positions)
    Gp = C.generator_matrix().delete_columns(list(non_pos))
    return Gp.rank() == k

        
def information_set_greedy(G, avoid):
    r"""
    Greedily select an information set of a matrix `G` while attempting to avoid
    the positions in `avoid`.

    The current implementation will simply attempt to compute the echelon form
    of the columns of `G` not in `avoid`. If this has full rank, the pivots are
    taken. If it does not have full rank, then the removed columns of `G` are
    appended at the back and an echelon form is recomputed.

    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,1,1,1,1,1,0,0],
                                 [0,0,0,1,1,0,1,1,0,0],
                                 [1,0,0,0,1,1,0,1,0,1]])
        sage: information_set_greedy(G, [])
        frozenset([0, 1, 3])
        sage: information_set_greedy(G, [0, 3])
        frozenset([1, 4, 5])
    """
    lavoid = list(avoid)
    lavoid.sort()
    Gpunctured = G.delete_columns(lavoid)
    # create a map from Gpunctured col number to G col number
    j = 0
    col_in_G = dict()
    for i in range(Gpunctured.ncols()):
        while j < len(lavoid) and i + j == lavoid[j]:
            j += 1
        col_in_G[i] = i + j

    # echelonize Gpunctured
    Gpunctured.echelonize()
    if Gpunctured.rank() == G.nrows():
        pivots = Gpunctured.pivots()
    else:
        # We need to overlap a bit
        # Put G after Gpunctured and echelonize again
        Gpunctured = G.delete_columns(lavoid)
        G2 = Gpunctured.augment(G)
        for j in range(Gpunctured.ncols(), G2.ncols()):
            col_in_G[j] = j - Gpunctured.ncols()
        G2.echelonize()
        pivots = G2.pivots()
    return frozenset(col_in_G[p] for p in pivots)
        


def covering_information_sets(C):
    r"""Compute a set of information sets ``I_1,...I_t`` of the code ``C`` such
    that each position is in at least one ``I_i``.

    Note that if all codewords are 0 on some position, then that position will
    not be covered by the information sets.
    
    The goal is that the ``I_i`` should overlap as little as possible.
    TODO: remarks on this implementation.

    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,1,1,1,1,1,0,0],
                                 [0,0,0,1,1,0,1,1,0,0],
                                 [1,0,0,0,1,1,0,1,0,1]])
        sage: C = LinearCode(G)
        sage: covering_information_sets(C)
        [frozenset([0, 1, 3]), frozenset([2, 4, 5]), frozenset([1, 6, 7]), frozenset([9, 3, 1])]
    """
    G = C.generator_matrix()
    zero_cols = set()
    for i in range(G.ncols()):
        if G.columns()[i].is_zero():
            zero_cols.add(i)
    uncovered = set(range(C.length()))
    uncovered = uncovered.difference(zero_cols)
    covered = zero_cols
    sets = []
    while uncovered:
        I = information_set_greedy(G, covered)
        covered = covered.union(I)
        uncovered = uncovered.difference(I)
        sets.append(I)
    return sets

def relative_ranks(information_sets):
    r"""Return the relative rank for the given information sets.

    The `i`th relative rank is the number of positions that were uncovered by
    the previous information sets.

    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,1,1,1,1,1,0,0],
                                 [0,0,0,1,1,0,1,1,0,0],
                                 [1,0,0,0,1,1,0,1,0,1]])
        sage: C = LinearCode(G)
        sage: isets = covering_information_sets(C); isets
        [frozenset([0, 1, 3]), frozenset([2, 4, 5]), frozenset([1, 6, 7]), frozenset([9, 3, 1])]
        sage: relative_ranks(isets)
        [3, 3, 2, 1]
    """
    covered = set()
    ranks = []
    for i in range(len(information_sets)):
        ranks.append(len(information_sets[i].difference(covered)))
        covered = covered.union(information_sets[i])
    return ranks

def minimum_weight_given_message_weight(G, mes_weight):
    """Brute-force compute the minimum weight of a codeword of the code
    generated by `G` given that the message has weight `w`.

    Note that `G` need not have full rank; this is to support using stunted
    systematic generator matrices as `G`.

    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,0,1],
                                 [0,1,0,1,0],
                                 [1,0,0,0,1]])
        sage: minimum_weight_given_message_weight(G, 1)
        2
        sage: minimum_weight_given_message_weight(G, 2)
        3
        sage: minimum_weight_given_message_weight(G, 3)
        3
    """
    n = G.ncols()
    k = G.nrows()
    F = G.base_ring()
    # Cache all multiple of the rows of G
    rows = dict()
    for e in F:
        if e != F.zero():
            rows[e] = (e * G).rows()
    wi = 0
    stack = [ (zero_vector(F, n), 0, 0) ]
    weight_min = n
    while True:
        if stack:
            (c, wi, fromi) = stack.pop()
        else:
            break
        if mes_weight == wi:
            weight_c = c.hamming_weight()
            if weight_c < weight_min:
               weight_min = weight_c
        if mes_weight == wi or fromi + (mes_weight - wi) > G.nrows():
            pass
        else:
            #normalise first non-zero element of message
            if wi == 0:
                stack.append((c + rows[F.one()][fromi], 1, fromi+1))
            else:
                for a in F:
                    if not a.is_zero():
                        stack.append((c + rows[a][fromi], wi+1, fromi+1))
            # also check that we don't use current position
            stack.append((c, wi, fromi+1))
    return weight_min

    # # The straightforward recursive version of the above:
    # def next(c, wi, fromi):
    #     if fromi + (mes_weight - wi) > len(rows):
    #         return None
    #     if mes_weight == wi:
    #         weight_c = c.hamming_weight()
    #         if weight_c < next.weight_min:
    #            next.weight_min = weight_c
    #            return dict()
    #         else:
    #             return None
    #     else:
    #         best = None
    #         for a in F:
    #             if not a.is_zero():
    #                 seq = next(c + rows[a][fromi], wi + 1, fromi + 1)
    #                 if not seq is None:
    #                     best = seq
    #                     best[fromi] = a
    #         seq = next(c, wi, fromi + 1)
    #         if not seq is None:
    #             best = seq
    #             best[fromi] = F.zero()
    #         return best
    # next.weight_min = n
    # seq = next(zero_vector(F, n), 0, 0)
    # return next.weight_min, seq


def systematic_generator_stunted(G, information_set):
    r"""
    Compute a systematic generator matrix given a generator matrix `G`, where
    the sought information set is as given, but return only the `n-k`
    non-identity columns.
    
    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,0,1],
                                 [0,1,0,1,0],
                                 [1,0,0,0,1]])
        sage: systematic_generator_stunted(G, [0,2,3])
        [0 1]
        [1 1]
        [1 0]
        sage: systematic_generator_stunted(G, [0,1,2])
        [0 1]
        [1 0]
        [1 1]
    """
    n = G.ncols()
    k = G.nrows()
    non_info = set(range(n)).difference(information_set)
    Gp = G.delete_columns(list(non_info))
    # assert(Gp.rank() == k)
    Gp = Gp.augment(G.delete_columns(list(information_set)))
    Gp.echelonize()
    Gp = Gp.delete_columns(range(k)) # remove the information set again
    return Gp

def brouwer_zimmermann(C, dmin = None, dmax = None):
    r"""
    Compute the minimum distance of the linear code `C` using the
    Brouwer--Zimmermann algorithm.

    The Brouwer--Zimmermann algorithm works by creating a cover of information
    sets of the positions of `C`. For each of these, it considers a systematic
    encoding of `C` at these positions. It then, for increasing message weights,
    generates all codewords from each systematic encoding with the given message
    weight. This allows it to maintain a lower bound on the minimum weight that
    a not-yet generated codeword could have. Once this lower bound gets above
    the so-far minimal weight codeword, we know a minimal weight codeword has
    been found.
    
    EXAMPLES::

        sage: G = matrix(GF(2), [[0,1,1,1,1,1,1,1,0,0],
                                 [0,0,0,1,1,0,1,1,0,0],
                                 [1,0,0,0,1,1,0,1,0,1]])
        sage: brouwer_zimmermann(LinearCode(G))
        3
    """
    n = C.length()
    k = C.dimension()
    if k == 0:
        return 0
    information_sets = covering_information_sets(C)
    ranks = relative_ranks(information_sets)
    # Compute stunted codes: for each information set, this is the code
    # consisting of only the remaining columns of G. Note that these might not
    # be real generator matrices, as they might not have full rank.
    # Retaining them like this is important as they will be used with
    # minimum_weight_given_message_weight
    G = C.generator_matrix()
    Gs = []
    for iset in information_sets:
        Gs.append(systematic_generator_stunted(G, iset))
    D = len(information_sets)

    # For each weight of the message
    if dmin is None:
        dmin = 1
    if dmax is None:
        dmax = n - k + 1 #TODO: Use all theoretical bounds
    for w in range(1, k+1):
        # print "message weight ", w
        for j in range(len(Gs)):
            # We compute the minimum weight codeword in stunted code Gp and add w (for the information part)
            # This is a w-sparsely constructed codeword in C given the basis [I | Gp] (up to permutation)
            Gp = Gs[j]
            wmin = minimum_weight_given_message_weight(Gp, w) + w
            if wmin < dmax:
                dmax = wmin
            dmin_new = sum(max(0, w + 1 - k + ranks[i]) for i in range(0,j)) + sum(max(0, w - k + ranks[i]) for i in range(j,len(Gs)))
            dmin = max(dmin, dmin_new) # without setting dmin > 1 from the beginning, dmin_new >= dmin always
            print "w %s dmin %s dmax %s" % (w, dmin, dmax)
            if dmax <= dmin:
                return dmax
    raise Exception("Internal error: The minimum distance should have been found now.")
        

    

    

### Tests
C = LinearCode(random_matrix(GF(2), 3, 10))
sets = covering_information_sets(C)
print sets


###
sets = covering_information_sets(C)
print sets
print relative_ranks(sets)
print brouwer_zimmermann(C)

### Hamming codes
C = codes.HammingCode(4, GF(2))
assert 3 == brouwer_zimmermann(C) , "Minimum distance of a Hamming code not correctly determined"
    
C = codes.HammingCode(4, GF(3))
assert 3 == brouwer_zimmermann(C) , "Minimum distance of a Hamming code not correctly determined"
    
C = codes.HammingCode(5, GF(3))
assert 3 == brouwer_zimmermann(C) , "Minimum distance of a Hamming code not correctly determined"
    
C = codes.HammingCode(3, GF(16,'a'))
assert 3 == brouwer_zimmermann(C) , "Minimum distance of a Hamming code not correctly determined"

print "All passed"

### GRS codes
C = codes.GeneralizedReedSolomonCode(GF(17).list(), 5)
assert C.minimum_distance() == brouwer_zimmermann(C)

C = codes.GeneralizedReedSolomonCode(GF(17).list(), 11)
assert C.minimum_distance() == brouwer_zimmermann(C)

C = codes.GeneralizedReedSolomonCode(GF(16,'a').list(), 11)
assert C.minimum_distance() == brouwer_zimmermann(C)

### Alternant codes (prime field)
def matrix_subfield(M):
    """Expand each row in the matrix M to its row-wise representation in the
    prime subfield of M.base_ring()"""
    Md = [ [ M[i,j]._vector_() for j in range(0, M.ncols()) ]
                               for i in range(0, M.nrows()) ]
    Fbig = M.base_ring()
    F = Fbig.prime_subfield()
    deg = Fbig.degree()
    return matrix(F, M.nrows()*deg, M.ncols(),
            lambda i,j: Md[i//deg][j][i%deg])

def subcode(Cbig):
    C = codes.LinearCodeFromCheckMatrix(matrix_subfield(Cbig.parity_check_matrix()))
    return C

def test_subcode(C):
    subC = subcode(C)
    bz_dmin = brouwer_zimmermann(subC)
    print "Code has distance %s (big code has %s)" % (bz_dmin, C.minimum_distance())
    assert bz_dmin >= C.minimum_distance() , "BZ returned an impossibly low min dist"

def random_grs_code(n, k, p=2):
    q = p^(ceil(log(n, p)))
    F = GF(q,'a')
    mults = [ random_non_zero(F) for i in range(n) ] 
    return codes.GeneralizedReedSolomonCode(sample(F.list(), n), k, column_multipliers=mults)

test_subcode(codes.GeneralizedReedSolomonCode(GF(16,'a').list(), 13))
test_subcode(codes.GeneralizedReedSolomonCode(GF(16,'a').list(), 12))

test_subcode(codes.GeneralizedReedSolomonCode(GF(16,'a').list(), 10))

C = codes.GeneralizedReedSolomonCode(GF(25,'a').list(), 20); Csub = subcode(C)
test_subcode(C)

# C= codes.GeneralizedReedSolomonCode(GF(7^2,'a').list()[1:], 29)
# subC = subcode(C)
# test_subcode(C)


### Timing tests
import time

set_random_seed(23)

def time_code(C):
    before = time.time()
    dmin = brouwer_zimmermann(C)
    after = time.time()
    print "%s:\t %s s." % (C, after - before)
    return after - before

time_code(codes.HammingCode(4, GF(2)))
time_code(codes.HammingCode(6, GF(3)))

time_code(subcode(random_grs_code(15,13)))
time_code(subcode(random_grs_code(26,23)))
time_code(subcode(random_grs_code(53,49)))
time_code(subcode(random_grs_code(110,105)))
time_code(subcode(random_grs_code(247,240)))
time_code(subcode(random_grs_code(500,490)))

time_code(subcode(random_grs_code(73, 60, p=3)))
time_code(subcode(random_grs_code(23, 19, p=5)))
time_code(subcode(random_grs_code(50, 45, p=11)))
time_code(subcode(random_grs_code(60, 50, p=5)))
time_code(subcode(random_grs_code(70, 60, p=11)))

# CACHED
# Linear code of length 15, dimension 11 over Finite Field of size 2:	 0.00089693069458 s.
# Linear code of length 364, dimension 358 over Finite Field of size 3:	 0.0982339382172 s.
# Linear code of length 15, dimension 7 over Finite Field of size 2:	 0.00147581100464 s.
# Linear code of length 26, dimension 11 over Finite Field of size 2:	 0.00289821624756 s.
# Linear code of length 53, dimension 29 over Finite Field of size 2:	 0.00355291366577 s.
# Linear code of length 110, dimension 75 over Finite Field of size 2:	 0.0196299552917 s.
# Linear code of length 247, dimension 191 over Finite Field of size 2:	 0.145899057388 s.
# Linear code of length 500, dimension 410 over Finite Field of size 2:	 0.899070978165 s.
# Linear code of length 73, dimension 21 over Finite Field of size 3:	 0.315680027008 s.
# Linear code of length 23, dimension 15 over Finite Field of size 5:	 0.0121469497681 s.
# Linear code of length 50, dimension 40 over Finite Field of size 11:	 22.8933241367 s.
# Linear code of length 60, dimension 30 over Finite Field of size 5:	 13.2168300152 s.
# time_code(subcode(random_grs_code(70, 60, p=11))) didn't finish in a few minutes



### Random-information set algorithm
def mindist_random_systematic_matrix(C):
    r"""
    Construct low-weight codewords by randomly permuting the columns of a
    generator matrix, running Gauss elimination on it, and then read the rows of
    the resulting systematic matrix.
    """
    n = C.length()
    k = C.dimension()
    G = C.generator_matrix()
    S = SymmetricGroup(n)
    def one_draw():
        Gp = copy(G)
        perm = S.random_element()
        Gp.permute_columns(perm)
        Gp.echelonize()
        omin = n
        cmin = None
        for c in Gp.rows():
            if c.hamming_weight() < omin:
                omin = c.hamming_weight()
                cmin = c
        return omin, cmin, perm
    dmin = n-k+1
    while True:
        omin, c, perm = one_draw()
        if omin < dmin:
            dmin = omin
            print "New minimial: %s.\nc = %s\nperm = %s" % (dmin, c, perm)
